/**
 * Malware Behavior Report Generator
 *
 * Analyzes code and generates a security report based on:
 * - Grok-detected malicious functions (MALWARE_ prefix)
 * - Grok-detected malicious variables
 * - Known suspicious patterns
 * - Obfuscator.io patterns (string array rotation, control flow flattening)
 */

const obfuscatorDetector = require('./detectors/obfuscator_io');

/**
 * Generate malware behavior report
 *
 * @param {Object} processingContext - Context with astScopes and grokInterface
 * @param {string} fileName - Source file name
 * @returns {Object} Report data
 */
function generateMalwareReport(processingContext, fileName) {
    const scopes = processingContext.astScopes || {};
    const grokStats = processingContext.grokInterface?.getTotalStats();

    const report = {
        fileName: fileName,
        timestamp: new Date().toISOString(),
        threats: [],
        suspiciousPatterns: [],
        obfuscationPatterns: [],
        cost: grokStats ? `$${grokStats.total_cost.toFixed(6)}` : 'N/A',
        summary: {
            totalFunctions: 0,
            maliciousFunctions: 0,
            totalVariables: 0,
            suspiciousVariables: 0
        }
    };

    // Analyze all scopes
    Object.values(scopes).forEach(scope => {
        if (!scope.variables) return;

        Object.values(scope.variables).forEach(variable => {
            // Check functions
            if (variable.value && variable.value.constructor?.name === 'Function') {
                report.summary.totalFunctions++;

                const func = variable.value;
                // Use grokSuggestedName if available, otherwise use variable.name
                const funcName = func.grokSuggestedName || variable.grokSuggestedName || variable.name;

                // Check for MALWARE_ prefix (Grok detected)
                if (funcName.startsWith('MALWARE_')) {
                    report.summary.maliciousFunctions++;

                    report.threats.push({
                        type: 'Malicious Function',
                        severity: 'HIGH',
                        name: funcName,
                        confidence: func.grokConfidence || 'high',
                        reason: func.grokReason || 'Grok AI detected malicious behavior',
                        callCount: func.callCount || 0
                    });
                }

                // Check for SUSPICIOUS_ prefix
                if (funcName.startsWith('SUSPICIOUS_')) {
                    report.threats.push({
                        type: 'Suspicious Function',
                        severity: 'MEDIUM',
                        name: funcName,
                        confidence: func.grokConfidence || 'medium',
                        reason: func.grokReason || 'Pattern-based suspicion',
                        callCount: func.callCount || 0
                    });
                }
            } else {
                // Check variables
                report.summary.totalVariables++;

                const varName = variable.name;

                // Check for suspicious variable names
                if (varName.startsWith('MALWARE_') || varName.startsWith('SUSPICIOUS_')) {
                    report.summary.suspiciousVariables++;

                    report.suspiciousPatterns.push({
                        type: 'Suspicious Variable',
                        name: varName,
                        confidence: variable.grokConfidence || 'medium',
                        reason: variable.grokReason || 'Suspicious naming pattern'
                    });
                }
            }
        });
    });

    // Detect obfuscator.io patterns
    if (processingContext.ast) {
        try {
            const obfuscationDetections = obfuscatorDetector.detectObfuscatorIO(
                processingContext.ast,
                processingContext
            );
            report.obfuscationPatterns = obfuscationDetections;
        } catch (err) {
            console.error('[Malware Report] Error detecting obfuscation:', err.message);
        }
    }

    // Calculate risk level
    report.riskLevel = calculateRiskLevel(report);

    return report;
}

/**
 * Calculate overall risk level
 */
function calculateRiskLevel(report) {
    const maliciousCount = report.summary.maliciousFunctions;
    const suspiciousCount = report.threats.filter(t => t.severity === 'MEDIUM').length;

    if (maliciousCount >= 3) return 'CRITICAL';
    if (maliciousCount >= 1) return 'HIGH';
    if (suspiciousCount >= 3) return 'MEDIUM';
    if (suspiciousCount >= 1) return 'LOW';
    return 'CLEAN';
}

/**
 * Format report as markdown
 */
function formatReportMarkdown(report) {
    let md = '';

    md += '# 🔍 Malware Analysis Report\n\n';
    md += `**File**: ${report.fileName}\n`;
    md += `**Date**: ${report.timestamp}\n`;
    md += `**Risk Level**: **${report.riskLevel}**\n`;
    md += `**Analysis Cost**: ${report.cost}\n\n`;

    md += '---\n\n';

    // Summary
    md += '## 📊 Summary\n\n';
    md += `- **Functions**: ${report.summary.totalFunctions} total, ${report.summary.maliciousFunctions} malicious\n`;
    md += `- **Variables**: ${report.summary.totalVariables} total, ${report.summary.suspiciousVariables} suspicious\n\n`;

    // Threats
    if (report.threats.length > 0) {
        md += '## 🚨 Detected Threats\n\n';
        report.threats.forEach((threat, idx) => {
            md += `### ${idx + 1}. ${threat.name}\n\n`;
            md += `- **Type**: ${threat.type}\n`;
            md += `- **Severity**: ${threat.severity}\n`;
            md += `- **Confidence**: ${threat.confidence}\n`;
            md += `- **Reason**: ${threat.reason}\n`;
            if (threat.callCount !== undefined) {
                md += `- **Call Count**: ${threat.callCount}\n`;
            }
            md += '\n';
        });
    } else {
        md += '## ✅ No Threats Detected\n\n';
        md += 'The code appears clean based on static analysis and AI detection.\n\n';
    }

    // Obfuscation patterns
    if (report.obfuscationPatterns && report.obfuscationPatterns.length > 0) {
        md += '## 🔒 Obfuscation Detected\n\n';
        report.obfuscationPatterns.forEach((pattern, idx) => {
            md += `### ${idx + 1}. ${pattern.pattern}\n\n`;
            md += `- **Confidence**: ${pattern.confidence}\n`;
            md += `- **Tool**: ${pattern.tool}\n`;
            md += `- **Description**: ${pattern.description}\n`;
            if (pattern.details) {
                md += `- **Details**: ${JSON.stringify(pattern.details, null, 2)}\n`;
            }
            md += '\n';
        });
    }

    // Suspicious patterns
    if (report.suspiciousPatterns.length > 0) {
        md += '## ⚠️  Suspicious Patterns\n\n';
        report.suspiciousPatterns.forEach((pattern, idx) => {
            md += `${idx + 1}. **${pattern.name}** (${pattern.confidence}): ${pattern.reason}\n`;
        });
        md += '\n';
    }

    md += '---\n\n';
    md += '*Generated by js_recover with Grok AI analysis*\n';

    return md;
}

/**
 * Format report as console output
 */
function formatReportConsole(report) {
    let output = '';

    output += '\n🔍 MALWARE ANALYSIS REPORT\n';
    output += '=========================\n';
    output += `File: ${report.fileName}\n`;
    output += `Risk Level: ${report.riskLevel}\n`;
    output += `Analysis Cost: ${report.cost}\n\n`;

    output += '📊 Summary\n';
    output += '----------\n';
    output += `Functions: ${report.summary.totalFunctions} (${report.summary.maliciousFunctions} malicious)\n`;
    output += `Variables: ${report.summary.totalVariables} (${report.summary.suspiciousVariables} suspicious)\n\n`;

    if (report.threats.length > 0) {
        output += '🚨 Detected Threats\n';
        output += '-------------------\n';
        report.threats.forEach((threat, idx) => {
            output += `${idx + 1}. [${threat.severity}] ${threat.name}\n`;
            output += `   ${threat.reason}\n`;
            output += `   Confidence: ${threat.confidence}\n\n`;
        });
    } else {
        output += '✅ No threats detected\n\n';
    }

    if (report.obfuscationPatterns && report.obfuscationPatterns.length > 0) {
        output += '🔒 Obfuscation Detected\n';
        output += '-----------------------\n';
        report.obfuscationPatterns.forEach((pattern, idx) => {
            output += `${idx + 1}. ${pattern.pattern} (${pattern.confidence})\n`;
            output += `   Tool: ${pattern.tool}\n`;
            output += `   ${pattern.description}\n\n`;
        });
    }

    return output;
}

module.exports = {
    generateMalwareReport,
    formatReportMarkdown,
    formatReportConsole
};
